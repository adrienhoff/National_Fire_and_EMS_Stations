<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>EMS Station Route Planner (Rate‐Limited)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Leaflet CSS & JS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    body, html { margin:0; padding:0; height:100% }
    #map { height:90% }
    #controls { padding:10px; font-family:Arial,sans-serif }
    input { width:200px; margin-right:10px }
    button { padding:5px 10px }
    #output { margin-top:5px }
  </style>
</head>
<body>
  <div id="controls">
    <form id="routeForm">
      Start: <input type="text" id="start" placeholder="Enter address or click map" />
      End:   <input type="text" id="end"   placeholder="Enter address or click map" />
      <button type="submit">Generate Route</button>
    </form>
    <div id="output"></div>
  </div>
  <div id="map"></div>

  <script>
    // —— CONFIG —— 
    const ORS_API_KEY        = 'eyJvcmciOiI1YjNjZTM1OTc4NTExMTAwMDFjZjYyNDgiLCJpZCI6ImEzMGQ1Y2Q3MDFiZjRhN2NhZTBhZTcyZTZlNGIzZGQ3IiwiaCI6Im11cm11cjY0In0=';
    const MAX_DETOUR_SECONDS = 1200;
    const FS_URL             = 'https://services3.arcgis.com/hFCLLQcFT7NdwqpA/arcgis/rest/services/Fire_and_Emergency_Medical_Service_(EMS)_Station_(2)/FeatureServer/0/query';
    const PAGE_SIZE          = 2000;

    // —— HELPERS —— 
    function sleep(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }

    // —— MAP SETUP —— 
    const map = L.map('map').setView([39.75, -105], 8);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);

    let startPoint = null, endPoint = null, allPOIs = [];
    let clickTarget = 'start';
    const startInput = document.getElementById('start');
    const endInput   = document.getElementById('end');
    const outputDiv  = document.getElementById('output');

    // —— CLICK TO SET START/END —— 
    map.on('click', e => {
      const { lat, lng } = e.latlng;
      if (clickTarget === 'start') {
        startPoint = [lng, lat];
        startInput.value = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
      } else {
        endPoint = [lng, lat];
        endInput.value = `${lat.toFixed(5)}, ${lng.toFixed(5)}`;
      }
      L.marker([lat, lng])
       .bindPopup(clickTarget.charAt(0).toUpperCase() + clickTarget.slice(1))
       .addTo(map).openPopup();
      clickTarget = clickTarget === 'start' ? 'end' : 'start';
    });

    // —— FETCH & DRAW POIs —— 
    async function fetchAllPOIs() {
      let features = [], offset = 0;
      while (true) {
        const url = `${FS_URL}?where=1%3D1&outFields=NAME&outSR=4326&f=geojson`
                  + `&resultOffset=${offset}&resultRecordCount=${PAGE_SIZE}`;
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) throw new Error('POI fetch failed: ' + res.status);
        const data = await res.json();
        const batch = data.features || [];
        features = features.concat(batch);
        if (batch.length < PAGE_SIZE) break;
        offset += PAGE_SIZE;
      }
      return features;
    }

    async function loadPOIs() {
      try {
        allPOIs = await fetchAllPOIs();
        allPOIs.forEach(f => {
          const [lng, lat] = f.geometry.coordinates;
          const name = f.properties.NAME || 'Unnamed';
          L.circleMarker([lat, lng], { radius: 3, color: 'gray' })
           .addTo(map).bindPopup(name);
        });
      } catch (err) {
        outputDiv.innerText = 'Error loading POIs: ' + err.message;
      }
    }
    loadPOIs();

    // —— SIMPLE GEOCODER —— 
    async function geocode(q) {
      const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/findAddressCandidates`
                + `?SingleLine=${encodeURIComponent(q)}&f=json`;
      const res = await fetch(url, { mode: 'cors' });
      if (!res.ok) throw new Error('Geocode failed: ' + res.status);
      const j = await res.json();
      const loc = j.candidates?.[0]?.location;
      if (loc) return [loc.x, loc.y];
      throw new Error('No geocode candidate for ' + q);
    }

    // —— JSON-only duration with retry on 429 —— 
    async function getDuration(coords) {
      const url = 'https://api.openrouteservice.org/v2/directions/driving-car/json';
      const body = JSON.stringify({ coordinates: coords });
      const maxRetries = 3;

      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        const res = await fetch(url, {
          mode: 'cors',
          method: 'POST',
          headers: {
            'Authorization': ORS_API_KEY,
            'Content-Type':  'application/json',
            'Accept':        'application/json'
          },
          body
        });

        if (res.ok) {
          const j = await res.json();
          return j.routes[0].summary.duration;
        }

        if (res.status === 429 && attempt < maxRetries) {
          // Rate limited—wait & retry
          const retryAfter = parseInt(res.headers.get('Retry-After') || '', 10);
          const wait = retryAfter
            ? retryAfter * 1000
            : Math.pow(2, attempt) * 1000;
          console.warn(`ORS 429, retrying in ${wait}ms (attempt ${attempt+1})`);
          await sleep(wait);
          continue;
        }

        // parse ORS error payload
        const err = await res.json().catch(() => ({}));
        if (err.error?.code === 2010) {
          // unroutable point—treat as infinite duration
          return Infinity;
        }
        throw new Error(
          `ORS error ${err.error?.code || res.status}: ` +
          (err.error?.message || JSON.stringify(err))
        );
      }
      throw new Error('ORS /json retry limit exceeded');
    }

    // —— FETCH GEOJSON FOR DRAWING ROUTE —— 
    async function fetchRouteGeo(coords) {
      const url  = 'https://api.openrouteservice.org/v2/directions/driving-car/geojson';
      const opts = {
        mode: 'cors',
        method: 'POST',
        headers: {
          'Authorization': ORS_API_KEY,
          'Content-Type':  'application/json',
          'Accept':        'application/json, application/geo+json'
        },
        body: JSON.stringify({ coordinates: coords })
      };

      const res = await fetch(url, opts);
      if (!res.ok) {
        const payload = await res.json().catch(() => ({}));
        console.error('ORS GeoJSON error:', payload.error);
        throw new Error(
          `ORS GeoJSON error ${payload.error?.code || res.status}: ` +
          (payload.error?.message || JSON.stringify(payload))
        );
      }
      const geo = await res.json();
      return {
        geo,
        duration: geo.features[0].properties.summary.duration
      };
    }

    // —— BBOX UTILITY —— 
    function getBBox(coords, pad=0.1) {
      const lats = coords.map(c=>c[1]), lngs = coords.map(c=>c[0]);
      return {
        minLat: Math.min(...lats)-pad,
        maxLat: Math.max(...lats)+pad,
        minLng: Math.min(...lngs)-pad,
        maxLng: Math.max(...lngs)+pad
      };
    }

    // —— FORM SUBMIT —— 
    document.getElementById('routeForm').addEventListener('submit', async e => {
      e.preventDefault();
      outputDiv.innerText = 'Calculating…';

      try {
        // 1) geocode if needed
        if (!startPoint) startPoint = await geocode(startInput.value.trim());
        if (!endPoint)   endPoint   = await geocode(endInput.value.trim());

        // 2) main route & base time
        const { geo:routeGeo, duration:baseTime } =
          await fetchRouteGeo([startPoint, endPoint]);

        // clear old route line
        map.eachLayer(l => {
          if (l.feature?.geometry?.type === 'LineString') map.removeLayer(l);
        });
        L.geoJSON(routeGeo, { color:'blue', weight:3 }).addTo(map);

        // 3) filter POIs by bbox
        const coords = routeGeo.features[0].geometry.coordinates;
        const { minLat, maxLat, minLng, maxLng } = getBBox(coords);
        const candidates = allPOIs.filter(f => {
          const [lng, lat] = f.geometry.coordinates;
          return lat>=minLat && lat<=maxLat && lng>=minLng && lng<=maxLng;
        });

        // clear old green markers
        map.eachLayer(l => {
          if (l.options?.color === 'green') map.removeLayer(l);
        });

        // 4) check detours in batches of 5
        const valid = [];
        const batchSize = 5;
        for (let i = 0; i < candidates.length; i += batchSize) {
          const chunk = candidates.slice(i, i + batchSize);
          await Promise.all(chunk.map(async f => {
            const [lng, lat] = f.geometry.coordinates;
            try {
              const toDur = await getDuration([startPoint, [lng,lat]]);
              const frDur = await getDuration([[lng,lat], endPoint]);
              if (toDur !== Infinity && frDur !== Infinity) {
                const detour = toDur + frDur - baseTime;
                if (detour <= MAX_DETOUR_SECONDS) {
                  valid.push({ lat, lng });
                  L.circleMarker([lat, lng], { radius:6, color:'green' })
                   .addTo(map);
                }
              }
            } catch (_) {
              // skip on any persistent error
            }
          }));
          // small pause between batches to avoid bursts
          await sleep(200);
        }

        // 5) share links
        const wp    = valid.map(p => `${p.lat},${p.lng}`);
        const gLink = `https://www.google.com/maps/dir/?api=1`
                    + `&origin=${startPoint[1]},${startPoint[0]}`
                    + `&destination=${endPoint[1]},${endPoint[0]}`
                    + `&waypoints=${wp.join('|')}`;
        const aLink = `https://maps.apple.com/?saddr=${startPoint[1]},${startPoint[0]}`
                    + `&daddr=${[...wp,`${endPoint[1]},${endPoint[0]}`].join('+to:')}`;

                    

        outputDiv.innerHTML = `
          <p>Valid POIs: ${valid.length}</p>
          <p><a href="${gLink}" target="_blank">Open in Google Maps</a></p>
          <p><a href="${aLink}"  target="_blank">Open in Apple Maps</a></p>
        `;
      } catch (err) {
        console.error('Route generation error:', err);
        outputDiv.innerText = 'Error: ' + err.message;
      }
    });
  </script>
</body>
</html>
